# -*- coding: utf-8 -*-
"""seasonalPattern v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zZm_2bBNVp3Y3fy7NT-M8_n6WgmgRXKi

Import necessary libraries, setup configurations and functions definitions
"""

import psycopg2
from psycopg2.extras import execute_values


# Setup Cell
from datetime import datetime, timedelta

# Constants
MIN_DAYS = 20
MAX_DAYS = 60
LOOK_AHEAD_DAYS = 100
YEARS_BACK = 10

# Function to safely adjust date for cross-year patterns
def adjust_cross_year_date(date, year):
    try:
        new_date = date.replace(year=year)
    except ValueError:
        # Handle February 29th in leap years by moving to the last day of February
        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
            # Leap year
            new_date = date.replace(year=year, day=29)
        else:
            # Non-leap year
            new_date = date.replace(year=year, day=28)
    return new_date

# Function to analyze a pattern and determine if it's bullish or bearish
def analyze_pattern(data, start_date, end_date):
    bullish_years = 0
    bearish_years = 0

    for year in range(start_date.year - YEARS_BACK, start_date.year):
        yearly_start_date = adjust_cross_year_date(start_date, year)
        yearly_end_date = adjust_cross_year_date(end_date, year)

        if yearly_end_date < yearly_start_date:
            yearly_end_date = adjust_cross_year_date(end_date, year + 1)

        if yearly_start_date not in data.index or yearly_end_date not in data.index:
            continue  # Skip if dates are not in the dataset

        start_price = data.at[yearly_start_date, 'Adj Close']
        end_price = data.at[yearly_end_date, 'Adj Close']

        if end_price > start_price:
            bullish_years += 1
        elif end_price < start_price:
            bearish_years += 1

    # Determine if the pattern is consistently bullish or bearish
    if bullish_years == YEARS_BACK or bearish_years == YEARS_BACK:
        return ['10/10', 'bullish' if bullish_years == YEARS_BACK else 'bearish']
    elif bullish_years == YEARS_BACK - 1 or bearish_years == YEARS_BACK - 1:
        return ['9/10', 'bullish' if bullish_years == YEARS_BACK - 1 else 'bearish']
    else:
        return 'None'


# Function to get yearly details of a pattern
def get_yearly_details(data, start_date, end_date):
    details = []
    for year in range(start_date.year - YEARS_BACK, start_date.year):
        yearly_start_date = adjust_cross_year_date(start_date, year)
        yearly_end_date = adjust_cross_year_date(end_date, year)

        if yearly_end_date < yearly_start_date:
            yearly_end_date = adjust_cross_year_date(end_date, year + 1)

        if yearly_start_date in data.index and yearly_end_date in data.index:
            start_price = data.at[yearly_start_date, 'Adj Close']
            end_price = data.at[yearly_end_date, 'Adj Close']
            profit = end_price - start_price
            profit_percent = (profit / start_price) * 100
            max_price = data.loc[yearly_start_date:yearly_end_date, 'Adj Close'].max()
            min_price = data.loc[yearly_start_date:yearly_end_date, 'Adj Close'].min()
            max_rise_percent = ((max_price - start_price) / start_price) * 100
            max_drop_percent = ((start_price - min_price) / start_price) * 100

            details.append({
                'year': year,
                'start_date': yearly_start_date,
                'end_date': yearly_end_date,
                'start_price': start_price,
                'end_price': end_price,
                'profit': profit,
                'profit_percent': profit_percent,
                'max_rise_percent': max_rise_percent,
                'max_drop_percent': max_drop_percent
            })
    return details

"""Futures Tickers"""

#tickers = ['GC=F', 'SI=F', 'PL=F', 'HG=F', 'CL=F', 'HO=F', 'RB=F', 'NG=F', 'ZC=F', 'ZW=F', 'ZS=F', 'ZM=F', 'ZL=F', 'CC=F', 'CT=F', 'KC=F', 'SB=F', 'LE=F', 'HE=F', '6A=F', '6B=F', '6C=F', '6E=F', '6J=F', '6S=F']
import pandas as pd
import yfinance as yf
#tickers = ['GC=F', 'SI=F', 'PL=F', 'HG=F', 'CL=F', 'HO=F', 'RB=F', 'NG=F', 'ZC=F', 'ZW=F', 'ZS=F', 'ZM=F', 'ZL=F', 'CC=F', 'CT=F', 'KC=F', 'SB=F', 'LE=F', 'HE=F']
tickers = ['RB=F']

"""Analysis"""

patterns = []
for ticker in tickers:

    try:
        print(f"Processing {ticker}...")
        stock_data = yf.download(ticker, period="max")
        stock_name = yf.Ticker(ticker).info["shortName"]

        # Check if the data is empty
        if stock_data.empty:
            print(f"No data found for {ticker}, skipping.")
            continue

        stock_data = stock_data.asfreq('D', method='bfill')

        today = pd.Timestamp(datetime.now().date())

        for day_offset in range(LOOK_AHEAD_DAYS):
            start_date = today + timedelta(days=day_offset)
            for duration in range(MIN_DAYS, MAX_DAYS + 1):
                end_date = start_date + timedelta(days=duration)
                if end_date > today + timedelta(days=LOOK_AHEAD_DAYS):
                    break
                pattern_type = analyze_pattern(stock_data, start_date, end_date)
                if pattern_type not in ['None']:
                    yearly_details = get_yearly_details(stock_data, start_date, end_date)
                    average_return = sum([d['profit_percent'] if pattern_type[1] == 'bullish' else -d['profit_percent'] for d in yearly_details]) / len(yearly_details)
                    #average_return = sum([d['profit_percent'] for d in yearly_details]) / len(yearly_details)
                    patterns.append({
                        'ticker': ticker,
                        'name': stock_name,
                        'start_date': start_date,
                        'end_date': end_date,
                        'pattern_type': pattern_type[1],
                        'ratio': pattern_type[0],
                        'average_return_percent': average_return,
                        'yearly_details': yearly_details
                    })
    except Exception as e:
        print(f"Error processing {ticker}: {e}, skipping.")
        continue

patterns.sort(key=lambda x: x['start_date'])

import json

def serialize_pattern(pattern):
    # Convert pattern dates to string format
    serialized_pattern = pattern.copy()
    serialized_pattern['start_date'] = pattern['start_date'].strftime('%Y-%m-%d')
    serialized_pattern['end_date'] = pattern['end_date'].strftime('%Y-%m-%d')
    for detail in serialized_pattern['yearly_details']:
        detail['start_date'] = detail['start_date'].strftime('%Y-%m-%d')
        detail['end_date'] = detail['end_date'].strftime('%Y-%m-%d')
    return serialized_pattern

# Process all patterns to get the best one for each start date
best_patterns = {}

for pattern in patterns:
    key = f"{pattern['ticker']}_{pattern['start_date'].strftime('%Y-%m-%d')}"
    if key in best_patterns:
        if pattern['average_return_percent'] > best_patterns[key]['average_return_percent']:
            best_patterns[key] = pattern
    else:
        best_patterns[key] = pattern

#patterns = [serialize_pattern(pattern) for pattern in best_patterns.values()]

import os

def connect_db():
    return psycopg2.connect(
        dbname=os.environ.get('DB_NAME', 'marinaschmid'), 
        user=os.environ.get('DB_USER', 'marinaschmid'), 
        password=os.environ.get('DB_PASSWORD', ''), 
        host=os.environ.get('DB_HOST', 'localhost')
    )


create_table_query = '''
CREATE TABLE IF NOT EXISTS futures_patterns (
    id SERIAL PRIMARY KEY,
    ticker VARCHAR(255),
    name VARCHAR(255),
    start_date DATE,
    end_date DATE,
    pattern_type VARCHAR(50),
    ratio VARCHAR(50),
    average_return_percent FLOAT,
    yearly_details JSONB
);
'''
def setup_database():
    conn = connect_db()
    cursor = conn.cursor()
    cursor.execute(create_table_query)
    conn.commit()
    cursor.close()
    conn.close()
setup_database()

try:
    conn = connect_db()
    cursor = conn.cursor()
    insert_query = '''
    INSERT INTO futures_patterns (ticker, name, start_date, end_date, pattern_type, ratio, average_return_percent, yearly_details)
    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
    '''
    for pattern in best_patterns.values():
        serialized_pattern = serialize_pattern(pattern)
        #print(f"{json.dumps(serialized_pattern['yearly_details'])}")
        cursor.execute(insert_query, (
            serialized_pattern['ticker'], 
            serialized_pattern['name'], 
            serialized_pattern['start_date'], 
            serialized_pattern['end_date'], 
            serialized_pattern['pattern_type'], 
            serialized_pattern['ratio'], 
            serialized_pattern['average_return_percent'], 
            json.dumps(serialized_pattern['yearly_details'])
        ))
    conn.commit()
    cursor.close()
    conn.close()
except Exception as e:
    print(f"Database error: {e}")

